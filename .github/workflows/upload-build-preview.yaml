name: "Upload Build: Preview"
# permissions:
#   actions: "read"
#   packages: "read"
#   repository-projects: "read"
#   security-events: "read"
#   statuses: "read"
#   contents: "read"
#   issues: "write"
#   pull-requests: "write"
#   deployments: "write"
permissions: "write-all"
on:
  pull_request_target:
    branches:
      # TODO: change this to "master" when things stabilize
      - "main"
    paths: 
      - "the-ui/**"
jobs:
  debug:
    runs-on: "ubuntu-latest"
    steps:
    - env:
        EVENT_CONTEXT: ${{ toJSON(github.event) }}
        sha: github.sha
        head_sha: github.head_sha
      run: echo "Expand this and look at 'env'."

  announce:
    name: "Announce deployments"
    runs-on: "ubuntu-latest"
    if: github.event.pull_request.state == 'open'
    outputs:
      staging_deployment_id: ${{ steps.create_deployments.staging_deployment_id }}
      prod_deployment_id: ${{ steps.create_deployments.prod_deployment_id }}
    steps:
    - uses: "actions/github-script@v6"
      id: create_deployments
      env:
        THE_BUILD_ID: ${{ github.event.pull_request.number }}
        BUILT_REF: ${{ github.event.pull_request.head.sha }}
      with:
        script: |
          ["staging", "prod"].forEach(async (cc_env) => {
            let deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: process.env.BUILT_REF,
              environment: `PR #${process.env.THE_BUILD_ID} (${cc_env} backend)`,
              transient_environment: true,
              required_contexts: [],
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: "in_progress",
              environment_url: `https://${process.env.THE_BUILD_ID}.${cc_env}.preview.example.com`,
            });

            core.setOutput(`${cc_env}_deployment_id`, deployment.data.id);
          });

  cleanup:
    name: "Clean up"
    runs-on: "ubuntu-latest"
    if: always()
    needs:
    - announce
    - wait_for_build
    - upload
    steps:
    - name: "Cancel in-progress deployments"
      uses: "actions/github-script@v6"
      if: contains(needs.*.result, 'cancelled') || contains(needs.*.result, 'failure')
      env:
        STAGING_ID: ${{ needs.announce.outputs.staging_deployment_id }}
        PROD_ID: ${{ needs.announce.outputs.prod_deployment_id }}
        RESULT: ${{ needs.wait_for_build.result != 'succeeded'  && needs.wait_for_build.result || needs.upload.result }}
      with:
        script: |
          [ process.env.STAGING_ID, process.env.PROD_ID ].forEach(async ([cc_env, deploymentId]) => {
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deploymentId,
              state: process.env.RESULT === "cancelled" ? "inactive" : "failure",
            });
          });

  wait_for_build:
    name: "Wait for build to complete"
    runs-on: "ubuntu-latest"
    if: github.event.pull_request.state == 'open'
    outputs:
      run_id: ${{ steps.get_run_id.run_id }}
    steps:
    - uses: "actions/github-script@v6"
      id: get_run_id
      timeout-minutes: 20
      env:
        BUILT_REF: ${{ github.event.pull_request.head.sha }}
      with:
        retry-exempt-status-codes: 400,401,403,422
        script: |
          const { setTimeout } = require("node:timers/promises");
          while (true) {
            console.log("polling...");
            try {
              const workflowRuns = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: ".github/workflows/build-ui-preview.yaml",
                head_sha: process.env.BUILT_REF,
                event: "pull_request",
                status: "completed",
              });

              if (workflowRuns.total_count > 0) {
                console.log("found workflow runs!", workflowRuns && workflowRuns.data && workflowRuns.data.workflow_runs);
                const run = workflowRuns[0];
                switch (run.conclusion) {
                  case "success":
                    core.setOutput("run_id", run.id);
                    return;
                  case "failure":
                    core.warning("UI build failed; nothing to upload");
                    return;
                  case "cancelled":
                    core.info("UI build canceled; nothing to upload");
                    return;
                  default:
                    core.setFailed(`unexpected conclusion '${run.conclusion}'`);
                    return;
                }
              }

              await setTimeout(1_000);
            } catch (e) {
              core.info(e);
              await setTimeout(1_000);
            }
          }

  upload:
    uses: "./.github/workflows/reusable--upload-build.yaml"
    needs: wait_for_build
    if: needs.wait_for_build.outputs.run_id
    with:
      the_build_id: ${{ github.event.pull_request.number }}
      build_type: "preview"
