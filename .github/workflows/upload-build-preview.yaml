name: "Upload Build: Preview"
on:
  pull_request_target:
    branches:
      # TODO: change this to "master" when things stabilize
      - "main"
    paths: 
      - "the-ui/**"
    types:
      - "opened"
      - "reopened"
      - "synchronize"
      - "closed"
jobs:
  debug:
    runs-on: "ubuntu-latest"
    steps:
    - env:
        EVENT_CONTEXT: ${{ toJSON(github.event) }}
        sha: github.sha
        head_sha: github.head_sha
      run: echo "Expand this and look at 'env'."

  announce:
    name: "Announce deployments"
    runs-on: "ubuntu-latest"
    if: github.event.pull_request.state == 'open'
    outputs:
      staging_deployment_id: ${{ steps.create_deployments.outputs.staging_deployment_id }}
      prod_deployment_id: ${{ steps.create_deployments.outputs.prod_deployment_id }}
    steps:
    - uses: "actions/github-script@v6"
      id: create_deployments
      env:
        THE_BUILD_ID: ${{ github.event.pull_request.number }}
        BUILT_REF: ${{ github.event.pull_request.head.sha }}
      with:
        script: |
          ["staging", "prod"].forEach(async (cc_env) => {
            let deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: process.env.BUILT_REF,
              environment: `UI Preview (${cc_env} backend)`,
              transient_environment: false,
              auto_merge: false,
              payload: {
                pr_number: ${{ github.event.pull_request.number }},
              },
              required_contexts: [],
              production_environment: false,
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: "in_progress",
              environment_url: `https://${process.env.THE_BUILD_ID}.${cc_env}.preview.crdb.io`,
              auto_inactive: false,
            });

            core.setOutput(`${cc_env}_deployment_id`, deployment.data.id);
          });

  update_deployments:
    name: "Update deployment statuses"
    runs-on: "ubuntu-latest"
    if: always()
    needs:
    - announce
    - wait_for_build
    - upload
    steps:
    - uses: "actions/github-script@v6"
      env:
        STAGING_ID: ${{ needs.announce.outputs.staging_deployment_id }}
        PROD_ID: ${{ needs.announce.outputs.prod_deployment_id }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
      with:
        script: |
          const results = ${{ toJSON(needs.*.result) }};
          const resolvedResult = results.find(res => res !== "success") || "success";

          let deploymentState = "";
          if (resolvedResult === "success" || resolvedResult === "failure") {
            deploymentState = resolvedResult;
          } else {
            deploymentState = "inactive";
          }

          [
            { id: process.env.STAGING_ID, env: "staging", },
            { id: process.env.PROD_ID, env: "prod" },
          ].forEach(async ({ id, env }) => {
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: id,
              state: deploymentState,
              environment_url: `https://${process.env.PR_NUMBER}.${env}.preview.crdb.io`,
              auto_inactive: false,
            });
          });

  wait_for_build:
    name: "Wait for build to complete"
    runs-on: "ubuntu-latest"
    if: github.event.pull_request.state == 'open'
    outputs:
      run_id: ${{ steps.get_run_id.outputs.run_id }}
    steps:
    - uses: "actions/github-script@v6"
      id: get_run_id
      timeout-minutes: 20
      env:
        BUILT_REF: ${{ github.event.pull_request.head.sha }}
      with:
        retry-exempt-status-codes: 400,401,403,422
        script: |
          const { setTimeout } = require("node:timers/promises");
          while (true) {
            try {
              const workflowRuns = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: ".github/workflows/build-ui-preview.yaml",
                head_sha: process.env.BUILT_REF,
                event: "pull_request",
                status: "completed",
              });

              if (workflowRuns.data.total_count > 0) {
                const run = workflowRuns.data.workflow_runs[0];
                switch (run.conclusion) {
                  case "success":
                    core.setOutput("run_id", run.id);
                    return;
                  case "failure":
                    core.warning("UI build failed; nothing to upload");
                    return;
                  case "cancelled":
                    core.info("UI build canceled; nothing to upload");
                    return;
                  default:
                    core.setFailed(`unexpected conclusion '${run.conclusion}'`);
                    return;
                }
              }

              await setTimeout(1_000);
            } catch (e) {
              core.info(e);
              await setTimeout(1_000);
            }
          }

  upload:
    uses: "./.github/workflows/reusable--upload-build.yaml"
    needs: wait_for_build
    if: needs.wait_for_build.outputs.run_id
    with:
      the_build_id: ${{ github.event.pull_request.number }}
      build_type: "preview"
      build_workflow_run_id: ${{ needs.wait_for_build.outputs.run_id }}
